# 6.4 Data Security Architecture

## Overview

Data Security Architecture encompasses the strategies, frameworks, and technologies used to protect data throughout its lifecycle. It addresses how data is encrypted, how cryptographic keys are managed, how sensitive computations are protected, and how privacy is embedded into system design from the ground up.

Data security is a critical component of any organization's overall security posture, ensuring confidentiality, integrity, and availability of information assets.

## Table of Contents

- [Encryption Architecture](#encryption-architecture)
- [Key Management (HSM / KMS)](#key-management-hsm--kms)
- [Confidential Computing](#confidential-computing)
- [Privacy-by-Design Architecture](#privacy-by-design-architecture)
- [Best Practices](#best-practices)
- [Related Resources](#related-resources)

---

## Encryption Architecture

### Concept

Encryption architecture defines how cryptographic algorithms and protocols are applied to protect data at rest, in transit, and in use. It establishes standards for encryption strength, algorithm selection, and implementation patterns.

### Types of Encryption

```
┌─────────────────────────────────────────────────────────────────┐
│                    ENCRYPTION TYPES                             │
├─────────────────────────────────────────────────────────────────┤
│  Data at Rest        │  Protects stored data (databases,       │
│                      │  file systems, backups, archives)        │
├──────────────────────┼──────────────────────────────────────────┤
│  Data in Transit     │  Protects data moving across networks   │
│                      │  (TLS, HTTPS, VPNs, secure channels)    │
├──────────────────────┼──────────────────────────────────────────┤
│  Data in Use         │  Protects data during processing        │
│                      │  (Confidential computing, enclaves)     │
└─────────────────────────────────────────────────────────────────┘
```

### Encryption Architecture Overview

```mermaid
graph TB
    subgraph "Encryption Architecture"
        subgraph "Data at Rest"
            A[Storage Layer] --> B[Disk Encryption]
            A --> C[Database Encryption]
            A --> D[File-Level Encryption]
        end
        
        subgraph "Data in Transit"
            E[Network Layer] --> F[TLS/SSL]
            E --> G[VPN Tunnels]
            E --> H[mTLS]
        end
        
        subgraph "Data in Use"
            I[Processing Layer] --> J[Memory Encryption]
            I --> K[Secure Enclaves]
            I --> L[Homomorphic Encryption]
        end
        
        subgraph "Key Management"
            M[KMS/HSM] --> B
            M --> C
            M --> F
            M --> J
        end
    end
```

### Symmetric vs Asymmetric Encryption

| Aspect | Symmetric Encryption | Asymmetric Encryption |
|--------|---------------------|----------------------|
| **Keys** | Single shared key | Public/Private key pair |
| **Speed** | Fast | Slower |
| **Use Case** | Bulk data encryption | Key exchange, digital signatures |
| **Examples** | AES, ChaCha20 | RSA, ECC, Ed25519 |
| **Key Distribution** | Challenging | Easier (public key can be shared) |

### Common Encryption Algorithms

| Algorithm | Type | Key Size | Use Case |
|-----------|------|----------|----------|
| **AES-256** | Symmetric | 256 bits | Data at rest, general encryption |
| **AES-GCM** | Symmetric (AEAD) | 128/256 bits | Authenticated encryption |
| **ChaCha20-Poly1305** | Symmetric (AEAD) | 256 bits | High-performance encryption |
| **RSA** | Asymmetric | 2048-4096 bits | Key exchange, signatures |
| **ECDSA** | Asymmetric | 256-384 bits | Digital signatures |
| **Ed25519** | Asymmetric | 256 bits | Modern signatures |

### Encryption Implementation Layers

```mermaid
graph TD
    subgraph "Application Layer"
        A1[Application-Level Encryption]
        A2[Field-Level Encryption]
        A3[Client-Side Encryption]
    end
    
    subgraph "Platform Layer"
        B1[Database TDE]
        B2[Storage Encryption]
        B3[Container Encryption]
    end
    
    subgraph "Infrastructure Layer"
        C1[Full Disk Encryption]
        C2[Network Encryption]
        C3[Hardware Encryption]
    end
    
    A1 --> B1
    A2 --> B2
    A3 --> B3
    B1 --> C1
    B2 --> C2
    B3 --> C3
```

### Transparent Data Encryption (TDE)

TDE encrypts database files at the storage level without requiring application changes.

**Architecture Flow:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    TDE ARCHITECTURE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│  │ Application │───▶│  Database   │───▶│  Encrypted  │        │
│  │   Query     │    │   Engine    │    │   Storage   │        │
│  └─────────────┘    └──────┬──────┘    └─────────────┘        │
│                            │                                    │
│                     ┌──────▼──────┐                            │
│                     │     DEK     │  Database Encryption Key   │
│                     └──────┬──────┘                            │
│                            │                                    │
│                     ┌──────▼──────┐                            │
│                     │     KEK     │  Key Encryption Key        │
│                     └──────┬──────┘                            │
│                            │                                    │
│                     ┌──────▼──────┐                            │
│                     │  KMS/HSM    │  Secure Key Storage        │
│                     └─────────────┘                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Envelope Encryption Pattern

Envelope encryption uses a hierarchy of keys to protect data efficiently:

```mermaid
graph TD
    subgraph "Key Hierarchy"
        A[Master Key / Root Key] --> B[Key Encryption Key KEK]
        B --> C1[Data Encryption Key 1]
        B --> C2[Data Encryption Key 2]
        B --> C3[Data Encryption Key N]
    end
    
    subgraph "Data Encryption"
        C1 --> D1[Encrypted Data Set 1]
        C2 --> D2[Encrypted Data Set 2]
        C3 --> D3[Encrypted Data Set N]
    end
    
    subgraph "Storage"
        D1 --> E1[Encrypted DEK1 + Ciphertext]
        D2 --> E2[Encrypted DEK2 + Ciphertext]
        D3 --> E3[Encrypted DEKN + Ciphertext]
    end
```

**Benefits of Envelope Encryption:**
- Limits the amount of data encrypted with a single key
- Enables efficient key rotation (only re-encrypt DEKs, not all data)
- Reduces exposure if a DEK is compromised
- Allows different DEKs for different data classifications

---

## Key Management (HSM / KMS)

### Concept

Key Management encompasses the policies, procedures, and technology used to generate, store, distribute, rotate, and revoke cryptographic keys. Proper key management is essential for maintaining the security of encrypted data.

### Key Lifecycle

```mermaid
graph LR
    A[Generation] --> B[Distribution]
    B --> C[Storage]
    C --> D[Usage]
    D --> E[Rotation]
    E --> F[Revocation]
    F --> G[Destruction]
    E --> D
```

### Key Management System (KMS) Architecture

```mermaid
graph TB
    subgraph "KMS Architecture"
        subgraph "Applications"
            A1[App 1]
            A2[App 2]
            A3[App N]
        end
        
        subgraph "KMS Layer"
            B[KMS API] --> C[Access Control]
            C --> D[Key Operations]
            D --> E[Audit Logging]
        end
        
        subgraph "Key Storage"
            F[HSM] 
            G[Software Keys]
            H[Key Vault]
        end
        
        A1 --> B
        A2 --> B
        A3 --> B
        D --> F
        D --> G
        D --> H
    end
```

### Hardware Security Module (HSM)

HSMs are dedicated hardware devices that provide secure key storage and cryptographic operations.

```
┌─────────────────────────────────────────────────────────────────┐
│                    HSM CHARACTERISTICS                          │
├─────────────────────────────────────────────────────────────────┤
│  Tamper Resistance  │  Physical protection against attacks     │
├─────────────────────┼───────────────────────────────────────────┤
│  Key Isolation      │  Keys never leave the HSM boundary       │
├─────────────────────┼───────────────────────────────────────────┤
│  Certified Security │  FIPS 140-2/3, Common Criteria           │
├─────────────────────┼───────────────────────────────────────────┤
│  High Performance   │  Hardware-accelerated crypto operations  │
├─────────────────────┼───────────────────────────────────────────┤
│  Audit Trail        │  Comprehensive logging of operations     │
└─────────────────────────────────────────────────────────────────┘
```

### HSM Types Comparison

| Type | Description | Use Case | Examples |
|------|-------------|----------|----------|
| **On-Premises HSM** | Physical device in data center | Highest security requirements | Thales Luna, Entrust nShield |
| **Cloud HSM** | Dedicated HSM in cloud | Cloud workloads needing FIPS 140-2 Level 3 | AWS CloudHSM, Azure Dedicated HSM |
| **Managed KMS** | Cloud-managed key service | General cloud encryption | AWS KMS, Azure Key Vault, GCP Cloud KMS |

### Key Hierarchy Design

```mermaid
graph TD
    subgraph "Key Hierarchy"
        A[Root Key / Master Key]
        A --> B1[Tenant Key 1]
        A --> B2[Tenant Key 2]
        
        B1 --> C1[Service Key A]
        B1 --> C2[Service Key B]
        B2 --> C3[Service Key C]
        
        C1 --> D1[Data Key 1]
        C1 --> D2[Data Key 2]
        C2 --> D3[Data Key 3]
        C3 --> D4[Data Key 4]
    end
    
    subgraph "Protection Level"
        E1[HSM Protected]
        E2[Software Protected]
        E3[Ephemeral]
    end
    
    A -.-> E1
    B1 -.-> E1
    B2 -.-> E1
    C1 -.-> E2
    C2 -.-> E2
    C3 -.-> E2
    D1 -.-> E3
    D2 -.-> E3
    D3 -.-> E3
    D4 -.-> E3
```

### Key Rotation Strategies

| Strategy | Description | Frequency | Impact |
|----------|-------------|-----------|--------|
| **Scheduled Rotation** | Automatic rotation on schedule | 30-365 days | Low - automated |
| **On-Demand Rotation** | Manual rotation when needed | As required | Medium - planned |
| **Emergency Rotation** | Immediate rotation after incident | Immediate | High - urgent |
| **Crypto Agility** | Algorithm upgrade rotation | As standards evolve | High - significant |

### BYOK (Bring Your Own Key)

```mermaid
sequenceDiagram
    participant Customer
    participant OnPremHSM as On-Prem HSM
    participant CloudKMS as Cloud KMS
    participant CloudHSM as Cloud HSM
    
    Customer->>OnPremHSM: Generate Key
    OnPremHSM->>OnPremHSM: Export Key (wrapped)
    OnPremHSM->>Customer: Wrapped Key Package
    Customer->>CloudKMS: Upload Wrapped Key
    CloudKMS->>CloudHSM: Import & Unwrap
    CloudHSM->>CloudKMS: Key Ready
    CloudKMS->>Customer: Key Available for Use
```

### Key Management Best Practices

1. **Separation of Duties**
   - Different roles for key creation, usage, and destruction
   - No single person has complete control

2. **Key Escrow and Recovery**
   - Secure backup procedures for critical keys
   - Documented recovery processes

3. **Access Controls**
   - Role-based access to keys
   - Multi-person authorization for sensitive operations

4. **Monitoring and Auditing**
   - Log all key operations
   - Alert on suspicious activities

---

## Confidential Computing

### Concept

Confidential Computing protects data in use by performing computation in a hardware-based Trusted Execution Environment (TEE). This ensures data remains encrypted even during processing, protecting against unauthorized access including from cloud providers and system administrators.

### The Data Protection Gap

```
┌─────────────────────────────────────────────────────────────────┐
│              TRADITIONAL DATA PROTECTION                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│    │  At Rest    │    │  In Transit │    │   In Use    │      │
│    │  ✓ Protected│    │  ✓ Protected│    │  ✗ Exposed  │      │
│    │  (Encrypted)│    │  (TLS/SSL)  │    │  (Plaintext)│      │
│    └─────────────┘    └─────────────┘    └─────────────┘      │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│              CONFIDENTIAL COMPUTING                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│    │  At Rest    │    │  In Transit │    │   In Use    │      │
│    │  ✓ Protected│    │  ✓ Protected│    │  ✓ Protected│      │
│    │  (Encrypted)│    │  (TLS/SSL)  │    │  (Enclave)  │      │
│    └─────────────┘    └─────────────┘    └─────────────┘      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Trusted Execution Environment (TEE) Architecture

```mermaid
graph TB
    subgraph "System Architecture"
        subgraph "Untrusted Zone"
            A[Operating System]
            B[Hypervisor]
            C[Other Applications]
        end
        
        subgraph "Trusted Execution Environment"
            D[Enclave Application]
            E[Sealed Storage]
            F[Attestation Service]
        end
        
        subgraph "Hardware"
            G[CPU with TEE Support]
            H[Memory Encryption Engine]
        end
    end
    
    C -.->|"Cannot Access"| D
    A -.->|"Cannot Access"| E
    B -.->|"Cannot Access"| D
    
    D --> G
    E --> H
    F --> G
```

### TEE Technologies Comparison

| Technology | Vendor | Type | Key Features |
|------------|--------|------|--------------|
| **Intel SGX** | Intel | Process-based | Small enclave size, attestation, sealing |
| **AMD SEV/SNP** | AMD | VM-based | Full VM encryption, memory integrity |
| **ARM TrustZone** | ARM | World-based | Secure world isolation, mobile focus |
| **Intel TDX** | Intel | VM-based | Trust domains, scalable protection |
| **AWS Nitro Enclaves** | AWS | VM-based | Isolated compute, attestation |

### Attestation Flow

Attestation proves that code is running in a genuine TEE with expected configuration.

```mermaid
sequenceDiagram
    participant Enclave
    participant Platform as Platform/CPU
    participant Attestation as Attestation Service
    participant Verifier as Remote Verifier
    
    Enclave->>Platform: Generate Quote Request
    Platform->>Platform: Create Evidence (Quote)
    Platform->>Enclave: Signed Quote
    Enclave->>Attestation: Submit Quote
    Attestation->>Attestation: Verify Signature
    Attestation->>Attestation: Check Measurements
    Attestation->>Verifier: Attestation Result
    Verifier->>Enclave: Trust Decision
```

### Confidential Computing Use Cases

| Use Case | Description | Benefit |
|----------|-------------|---------|
| **Multi-party Computation** | Multiple parties compute on combined data | No party sees others' raw data |
| **Secure AI/ML** | Train models on sensitive data | Protect training data and model |
| **Healthcare Analytics** | Process patient data | HIPAA compliance, privacy |
| **Financial Services** | Cross-institution analysis | Regulatory compliance |
| **Key Management** | Protect cryptographic operations | Keys never exposed |

### Confidential Computing Architecture Pattern

```mermaid
graph TB
    subgraph "Client"
        A[User Application]
        B[Enclave Client SDK]
    end
    
    subgraph "Cloud"
        subgraph "Confidential VM/Container"
            C[Enclave Runtime]
            D[Application Logic]
            E[Encrypted Memory]
        end
        
        subgraph "Attestation"
            F[Attestation Service]
            G[Policy Engine]
        end
    end
    
    subgraph "Key Management"
        H[Key Vault / HSM]
    end
    
    A --> B
    B -->|Encrypted Channel| C
    C --> D
    D --> E
    B --> F
    F --> G
    G -->|Release Keys| H
    H -->|Sealed Keys| C
```

---

## Privacy-by-Design Architecture

### Concept

Privacy-by-Design (PbD) is an approach that embeds privacy into the design and architecture of IT systems and business practices from the outset, rather than as an afterthought.

### The Seven Foundational Principles

```
┌─────────────────────────────────────────────────────────────────┐
│              PRIVACY-BY-DESIGN PRINCIPLES                       │
├─────────────────────────────────────────────────────────────────┤
│  1. Proactive not Reactive      │  Anticipate privacy risks    │
├─────────────────────────────────┼───────────────────────────────┤
│  2. Privacy as Default          │  Maximum privacy by default  │
├─────────────────────────────────┼───────────────────────────────┤
│  3. Privacy in Design           │  Core functionality, not add-on│
├─────────────────────────────────┼───────────────────────────────┤
│  4. Full Functionality          │  Privacy + Security together │
├─────────────────────────────────┼───────────────────────────────┤
│  5. End-to-End Lifecycle        │  Cradle to grave protection  │
├─────────────────────────────────┼───────────────────────────────┤
│  6. Visibility & Transparency   │  Open and verifiable         │
├─────────────────────────────────┼───────────────────────────────┤
│  7. User-Centric                │  Respect user privacy        │
└─────────────────────────────────────────────────────────────────┘
```

### Privacy Architecture Framework

```mermaid
graph TB
    subgraph "Privacy Architecture Layers"
        subgraph "Policy Layer"
            A[Privacy Policies]
            B[Consent Management]
            C[Data Subject Rights]
        end
        
        subgraph "Control Layer"
            D[Access Controls]
            E[Purpose Limitation]
            F[Data Minimization]
        end
        
        subgraph "Protection Layer"
            G[Encryption]
            H[Anonymization]
            I[Pseudonymization]
        end
        
        subgraph "Governance Layer"
            J[Data Inventory]
            K[Privacy Impact Assessment]
            L[Compliance Monitoring]
        end
    end
    
    A --> D
    B --> E
    C --> F
    D --> G
    E --> H
    F --> I
    G --> J
    H --> K
    I --> L
```

### Data Minimization Strategies

| Strategy | Description | Implementation |
|----------|-------------|----------------|
| **Collection Limitation** | Only collect necessary data | Field-level validation, purpose-driven forms |
| **Storage Limitation** | Retain only as long as needed | Retention policies, automatic deletion |
| **Access Limitation** | Restrict who can see data | RBAC, need-to-know basis |
| **Processing Limitation** | Only process for stated purpose | Purpose binding, audit trails |

### Anonymization vs Pseudonymization

```mermaid
graph TD
    subgraph "Original Data"
        A[Personal Data]
    end
    
    subgraph "Anonymization"
        B[Remove Identifiers]
        C[Apply k-anonymity]
        D[Add Noise / Differential Privacy]
        E[Aggregation]
        F[Anonymous Data - Not Reversible]
    end
    
    subgraph "Pseudonymization"
        G[Replace Identifiers]
        H[Token/Key Mapping]
        I[Pseudonymous Data - Reversible]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    
    A --> G
    G --> H
    H --> I
```

### Privacy-Enhancing Technologies (PETs)

| Technology | Description | Use Case |
|------------|-------------|----------|
| **Differential Privacy** | Add noise to query results | Analytics on sensitive data |
| **Homomorphic Encryption** | Compute on encrypted data | Outsourced computation |
| **Secure Multi-party Computation** | Joint computation, no data sharing | Collaborative analytics |
| **Zero-Knowledge Proofs** | Prove without revealing | Identity verification |
| **Federated Learning** | Train ML without centralizing data | Privacy-preserving AI |
| **Synthetic Data** | Generate artificial datasets | Testing, development |

### Data Subject Rights Architecture

```mermaid
graph LR
    subgraph "Data Subject Rights"
        A[Right to Access]
        B[Right to Rectification]
        C[Right to Erasure]
        D[Right to Portability]
        E[Right to Object]
        F[Right to Restrict Processing]
    end
    
    subgraph "Technical Implementation"
        G[Data Discovery]
        H[Data Inventory]
        I[Automated Workflows]
        J[Export Capabilities]
        K[Deletion Mechanisms]
        L[Consent Management]
    end
    
    A --> G
    A --> H
    B --> I
    C --> K
    D --> J
    E --> L
    F --> L
```

### Privacy Architecture for GDPR/CCPA Compliance

```mermaid
graph TB
    subgraph "Compliance Architecture"
        subgraph "Data Governance"
            A[Data Classification]
            B[Data Mapping]
            C[Processing Records]
        end
        
        subgraph "Privacy Controls"
            D[Consent Management Platform]
            E[Privacy Preference Center]
            F[DSAR Portal]
        end
        
        subgraph "Technical Measures"
            G[Encryption at Rest/Transit]
            H[Access Controls]
            I[Audit Logging]
        end
        
        subgraph "Operational"
            J[Privacy Impact Assessments]
            K[Breach Response]
            L[Vendor Management]
        end
    end
    
    A --> D
    B --> E
    C --> F
    D --> G
    E --> H
    F --> I
    G --> J
    H --> K
    I --> L
```

---

## Best Practices

### Encryption Best Practices

1. **Use Strong, Modern Algorithms**
   - AES-256 for symmetric encryption
   - RSA-2048+ or ECC for asymmetric
   - Avoid deprecated algorithms (DES, 3DES, MD5, SHA-1)

2. **Implement Defense in Depth**
   - Layer encryption at multiple levels
   - Don't rely on a single encryption point

3. **Secure Key Management**
   - Use HSMs for high-value keys
   - Implement proper key rotation
   - Never hardcode keys in source code

4. **Validate Implementations**
   - Use well-tested crypto libraries
   - Avoid custom cryptographic implementations
   - Regular security assessments

### Key Management Best Practices

1. **Centralize Key Management**
   - Use enterprise KMS solutions
   - Maintain key inventory

2. **Implement Least Privilege**
   - Separate key admin from key usage
   - Role-based access controls

3. **Plan for Key Recovery**
   - Document recovery procedures
   - Test recovery regularly

4. **Monitor and Audit**
   - Log all key operations
   - Alert on anomalies

### Privacy Best Practices

1. **Data Minimization**
   - Collect only what's needed
   - Delete when no longer required

2. **Purpose Limitation**
   - Use data only for stated purposes
   - Document processing activities

3. **Transparency**
   - Clear privacy notices
   - Easy-to-use consent mechanisms

4. **Security Measures**
   - Encrypt personal data
   - Implement access controls
   - Regular privacy assessments

---

## Related Resources

### Internal References

- [6.1 Security Architecture](./6.1-security-architecture.md) - Zero Trust, Defense in Depth
- [6.2 Identity Architecture](./6.2-identity-architecture.md) - Identity Management, Authentication
- [6.3 Network Security Architecture](./6.3-network-security-architecture.md) - Network Security Controls

### External Resources

- [NIST Cryptographic Standards](https://csrc.nist.gov/publications/fips)
- [Confidential Computing Consortium](https://confidentialcomputing.io/)
- [GDPR Official Text](https://gdpr.eu/)
- [CCPA Resources](https://oag.ca.gov/privacy/ccpa)
- [Privacy by Design Principles](https://www.ipc.on.ca/wp-content/uploads/resources/7foundationalprinciples.pdf)

### Azure Implementation

- [Azure Key Vault](../../architecture-azure/security/)
- [Azure Confidential Computing](../../architecture-azure/security/)
- [Azure Information Protection](../../architecture-azure/security/)
