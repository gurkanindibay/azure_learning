# 6.2 Identity Architecture

## Overview

Identity Architecture defines the framework for managing digital identities, authentication, authorization, and access control across an organization's systems. It establishes how users, services, and devices are identified, verified, and granted appropriate access to resources.

Modern identity architecture is the cornerstone of security, enabling organizations to implement Zero Trust principles while providing seamless user experiences.

## Table of Contents

- [Core Identity Concepts](#core-identity-concepts)
- [Identity Providers (IdP)](#identity-providers-idp)
- [Authentication Architecture](#authentication-architecture)
- [Authorization Architecture](#authorization-architecture)
- [Federation Architecture](#federation-architecture)
- [Managed Identity Architecture](#managed-identity-architecture)
- [Identity Lifecycle Management](#identity-lifecycle-management)
- [Identity Governance](#identity-governance)
- [Best Practices](#best-practices)
- [Related Resources](#related-resources)

---

## Core Identity Concepts

### What is Digital Identity?

A digital identity is the collection of attributes and credentials that represent an entity (user, service, or device) in a digital system.

```
┌─────────────────────────────────────────────────────────────────┐
│                     DIGITAL IDENTITY                            │
├─────────────────────────────────────────────────────────────────┤
│  Component          │  Description                              │
├─────────────────────┼───────────────────────────────────────────┤
│  Identifier         │  Unique value (username, email, UUID)     │
├─────────────────────┼───────────────────────────────────────────┤
│  Attributes         │  Properties (name, role, department)      │
├─────────────────────┼───────────────────────────────────────────┤
│  Credentials        │  Proof of identity (password, cert, key)  │
├─────────────────────┼───────────────────────────────────────────┤
│  Entitlements       │  Permissions and access rights            │
└─────────────────────────────────────────────────────────────────┘
```

### Identity Types

| Identity Type | Description | Examples |
|---------------|-------------|----------|
| **Human Identity** | Real users accessing systems | Employees, contractors, customers |
| **Service Identity** | Applications and services | APIs, microservices, background jobs |
| **Device Identity** | Hardware and IoT devices | Laptops, phones, sensors |
| **Workload Identity** | Cloud workloads and containers | VMs, containers, serverless functions |

### Identity Architecture Layers

```mermaid
graph TB
    subgraph "Identity Architecture Layers"
        A[Applications & Services]
        B[Access Management Layer]
        C[Identity Provider Layer]
        D[Directory Services Layer]
        E[Identity Governance Layer]
        
        A --> B
        B --> C
        C --> D
        D --> E
    end
    
    subgraph "Cross-Cutting Concerns"
        F[Audit & Logging]
        G[Monitoring]
        H[Compliance]
    end
    
    B -.-> F
    C -.-> G
    E -.-> H
```

---

## Identity Providers (IdP)

### Role of Identity Providers

An Identity Provider (IdP) is a trusted system that creates, maintains, and manages identity information while providing authentication services to relying applications.

### IdP Architecture Pattern

```mermaid
sequenceDiagram
    participant User
    participant App as Application (SP)
    participant IdP as Identity Provider
    participant Dir as Directory
    
    User->>App: 1. Access Request
    App->>IdP: 2. Redirect to IdP
    User->>IdP: 3. Authenticate
    IdP->>Dir: 4. Validate Credentials
    Dir-->>IdP: 5. User Found
    IdP->>IdP: 6. Generate Token
    IdP-->>User: 7. Return Token
    User->>App: 8. Present Token
    App->>App: 9. Validate & Grant Access
```

### Common Identity Providers

| Provider Type | Use Case | Examples |
|---------------|----------|----------|
| **Enterprise IdP** | Internal workforce | Azure AD, Okta, Ping Identity |
| **Social IdP** | Consumer applications | Google, Facebook, Apple |
| **Government IdP** | Civic services | Login.gov, GOV.UK Verify |
| **Custom IdP** | Specialized needs | Self-hosted Keycloak, IdentityServer |

### IdP Selection Criteria

1. **Protocol Support**: OAuth 2.0, OIDC, SAML 2.0, WS-Federation
2. **Scalability**: User volume and geographic distribution
3. **Integration**: APIs, SDKs, and connector availability
4. **Compliance**: Industry standards (SOC 2, ISO 27001, HIPAA)
5. **User Experience**: SSO, passwordless, adaptive authentication

---

## Authentication Architecture

### Authentication Factors

```
┌─────────────────────────────────────────────────────────────────┐
│                   AUTHENTICATION FACTORS                        │
├─────────────────────────────────────────────────────────────────┤
│  Factor Type      │  Description         │  Examples            │
├───────────────────┼──────────────────────┼──────────────────────┤
│  Something You    │  Knowledge-based     │  Passwords, PINs,    │
│  KNOW             │                      │  Security questions  │
├───────────────────┼──────────────────────┼──────────────────────┤
│  Something You    │  Possession-based    │  Phone, hardware     │
│  HAVE             │                      │  token, smart card   │
├───────────────────┼──────────────────────┼──────────────────────┤
│  Something You    │  Inherence-based     │  Fingerprint, face,  │
│  ARE              │                      │  voice, iris         │
├───────────────────┼──────────────────────┼──────────────────────┤
│  Somewhere You    │  Location-based      │  IP address, GPS,    │
│  ARE              │                      │  network             │
├───────────────────┼──────────────────────┼──────────────────────┤
│  Something You    │  Behavior-based      │  Typing pattern,     │
│  DO               │                      │  mouse movement      │
└─────────────────────────────────────────────────────────────────┘
```

### Multi-Factor Authentication (MFA) Architecture

```mermaid
flowchart TD
    A[User Login Attempt] --> B{Primary Factor}
    B -->|Password Valid| C{Risk Assessment}
    B -->|Password Invalid| D[Deny Access]
    
    C -->|Low Risk| E[Grant Access]
    C -->|Medium Risk| F{Second Factor}
    C -->|High Risk| G{Additional Verification}
    
    F -->|OTP Valid| E
    F -->|OTP Invalid| D
    
    G -->|Biometric Valid| E
    G -->|Biometric Invalid| D
    
    subgraph "Risk Signals"
        H[Device Trust]
        I[Location]
        J[Time of Access]
        K[User Behavior]
    end
    
    H --> C
    I --> C
    J --> C
    K --> C
```

### Authentication Protocols

| Protocol | Use Case | Token Type | Key Features |
|----------|----------|------------|--------------|
| **OAuth 2.0** | Authorization delegation | Access Token | Scopes, refresh tokens |
| **OAuth 2.0 + PKCE** | Public clients (SPAs, mobile) | Access Token | Code verifier/challenge, no client secret |
| **OpenID Connect** | Authentication + identity | ID Token (JWT) | Claims, userinfo endpoint |
| **SAML 2.0** | Enterprise SSO | SAML Assertion | XML-based, mature ecosystem |
| **FIDO2/WebAuthn** | Passwordless | Public key credential | Phishing-resistant |
| **Kerberos** | On-premises SSO | Ticket | Mutual authentication |

### OAuth 2.0 with PKCE (Proof Key for Code Exchange)

#### What is PKCE?

PKCE (pronounced "pixy") is a security extension to OAuth 2.0 that protects the authorization code flow from interception attacks. It was originally designed for mobile and native applications (public clients) that cannot securely store a client secret, but is now recommended for **all OAuth clients**, including web applications.

#### Why PKCE is Needed

```
┌─────────────────────────────────────────────────────────────────┐
│              AUTHORIZATION CODE INTERCEPTION ATTACK             │
├─────────────────────────────────────────────────────────────────┤
│  Without PKCE:                                                  │
│  1. User initiates login → App requests authorization code      │
│  2. Authorization server returns code via redirect URI          │
│  3. ⚠️ Malicious app intercepts the authorization code          │
│  4. ⚠️ Attacker exchanges code for access token                 │
│  5. ⚠️ Attacker gains unauthorized access                       │
├─────────────────────────────────────────────────────────────────┤
│  With PKCE:                                                     │
│  1. App generates code_verifier and code_challenge              │
│  2. App sends code_challenge with authorization request         │
│  3. Even if code is intercepted, attacker lacks code_verifier   │
│  4. ✅ Token exchange fails without original code_verifier      │
└─────────────────────────────────────────────────────────────────┘
```

#### PKCE Flow Components

| Component | Description | Generation |
|-----------|-------------|------------|
| **code_verifier** | High-entropy cryptographic random string | 43-128 characters, URL-safe |
| **code_challenge** | Derived from code_verifier | `BASE64URL(SHA256(code_verifier))` |
| **code_challenge_method** | Hash algorithm used | `S256` (recommended) or `plain` |

#### OAuth 2.0 + PKCE Authorization Flow

```mermaid
sequenceDiagram
    participant User
    participant Client as Client App
    participant AuthServer as Authorization Server
    participant API as Resource Server
    
    Note over Client: Generate code_verifier (random string)
    Note over Client: Create code_challenge = SHA256(code_verifier)
    
    User->>Client: 1. Click Login
    Client->>AuthServer: 2. Authorization Request<br/>+ code_challenge<br/>+ code_challenge_method=S256
    AuthServer->>User: 3. Login Page
    User->>AuthServer: 4. Enter Credentials
    AuthServer->>AuthServer: 5. Store code_challenge
    AuthServer->>Client: 6. Authorization Code (via redirect)
    
    Client->>AuthServer: 7. Token Request<br/>+ authorization_code<br/>+ code_verifier
    AuthServer->>AuthServer: 8. Verify: SHA256(code_verifier) == stored code_challenge
    AuthServer->>Client: 9. Access Token + Refresh Token
    
    Client->>API: 10. API Request + Access Token
    API->>Client: 11. Protected Resource
```

#### PKCE Implementation Example

**Step 1: Generate Code Verifier and Challenge**

```javascript
// Generate a cryptographically random code_verifier
function generateCodeVerifier() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return base64URLEncode(array);
}

// Create code_challenge from code_verifier
async function generateCodeChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const digest = await crypto.subtle.digest('SHA-256', data);
    return base64URLEncode(new Uint8Array(digest));
}

// Base64 URL encoding (no padding, URL-safe characters)
function base64URLEncode(buffer) {
    return btoa(String.fromCharCode(...buffer))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}
```

**Step 2: Authorization Request**

```
GET /authorize?
    response_type=code
    &client_id=your_client_id
    &redirect_uri=https://app.example.com/callback
    &scope=openid profile email
    &state=random_state_value
    &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
    &code_challenge_method=S256
```

**Step 3: Token Exchange Request**

```
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&code=received_authorization_code
&redirect_uri=https://app.example.com/callback
&client_id=your_client_id
&code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

#### PKCE Best Practices

| Practice | Recommendation |
|----------|----------------|
| **Always use S256** | Never use `plain` method in production |
| **Generate verifier per request** | Never reuse code_verifier values |
| **Use cryptographic randomness** | Use `crypto.getRandomValues()` or equivalent |
| **Store verifier securely** | Keep in memory or secure session storage |
| **Validate state parameter** | Prevent CSRF attacks alongside PKCE |
| **Use PKCE for all clients** | Not just public clients - confidential clients benefit too |

#### When to Use PKCE

```
┌─────────────────────────────────────────────────────────────────┐
│                    PKCE USAGE GUIDELINES                        │
├─────────────────────────────────────────────────────────────────┤
│  Client Type          │  PKCE Required?  │  Reason              │
├───────────────────────┼──────────────────┼──────────────────────┤
│  Single Page Apps     │  ✅ Required     │  Cannot store secret │
│  (SPAs)               │                  │  securely            │
├───────────────────────┼──────────────────┼──────────────────────┤
│  Mobile/Native Apps   │  ✅ Required     │  Code interception   │
│                       │                  │  risk via custom URI │
├───────────────────────┼──────────────────┼──────────────────────┤
│  Desktop Apps         │  ✅ Required     │  Cannot store secret │
│                       │                  │  securely            │
├───────────────────────┼──────────────────┼──────────────────────┤
│  Server-Side Web Apps │  ✅ Recommended  │  Defense in depth    │
│                       │                  │  (OAuth 2.1 requires)│
├───────────────────────┼──────────────────┼──────────────────────┤
│  Machine-to-Machine   │  ❌ Not needed   │  Uses client         │
│  (M2M)                │                  │  credentials flow    │
└─────────────────────────────────────────────────────────────────┘
```

#### PKCE vs Traditional Authorization Code Flow

```mermaid
flowchart LR
    subgraph "Traditional (Confidential Clients)"
        A1[Client Secret] --> B1[Stored on Server]
        B1 --> C1[Sent with Token Request]
    end
    
    subgraph "PKCE (All Clients)"
        A2[Code Verifier] --> B2[Generated Per Request]
        B2 --> C2[Challenge Sent First]
        C2 --> D2[Verifier Proves Ownership]
    end
    
    subgraph "Security Comparison"
        E1[Secret can be leaked/stolen]
        E2[Verifier never leaves client until exchange]
    end
```

> **Note**: OAuth 2.1 (draft) mandates PKCE for all clients using the authorization code flow, making it the standard security practice going forward.

### Passwordless Authentication Architecture

```mermaid
graph LR
    subgraph "Passwordless Methods"
        A[FIDO2 Security Keys]
        B[Biometrics]
        C[Authenticator Apps]
        D[Magic Links]
        E[Certificate-Based]
    end
    
    subgraph "Benefits"
        F[No Password Fatigue]
        G[Phishing Resistant]
        H[Better UX]
        I[Reduced Help Desk]
    end
    
    A --> F
    B --> G
    C --> H
    D --> I
    E --> G
```

---

## Authorization Architecture

### Authorization Models

#### 1. Role-Based Access Control (RBAC)

```mermaid
graph TD
    subgraph "RBAC Model"
        U[Users] --> R[Roles]
        R --> P[Permissions]
        P --> Res[Resources]
    end
    
    subgraph "Example"
        U1[John] --> R1[Admin]
        U2[Jane] --> R2[Editor]
        U3[Bob] --> R3[Viewer]
        
        R1 --> P1[Create, Read, Update, Delete]
        R2 --> P2[Create, Read, Update]
        R3 --> P3[Read]
    end
```

#### 2. Attribute-Based Access Control (ABAC)

```
┌─────────────────────────────────────────────────────────────────┐
│                        ABAC COMPONENTS                          │
├─────────────────────────────────────────────────────────────────┤
│  Subject Attributes  │  User role, department, clearance level │
├──────────────────────┼──────────────────────────────────────────┤
│  Resource Attributes │  Classification, owner, type            │
├──────────────────────┼──────────────────────────────────────────┤
│  Action Attributes   │  Read, write, delete, approve           │
├──────────────────────┼──────────────────────────────────────────┤
│  Environment Attrs   │  Time, location, device, threat level   │
└─────────────────────────────────────────────────────────────────┘

Policy Example:
IF subject.role = "Manager" 
AND resource.classification ≤ "Confidential"
AND environment.location = "Corporate Network"
AND environment.time BETWEEN "09:00" AND "18:00"
THEN ALLOW action.read
```

#### 3. Policy-Based Access Control (PBAC)

```mermaid
flowchart LR
    A[Access Request] --> B[Policy Enforcement Point PEP]
    B --> C[Policy Decision Point PDP]
    C --> D[Policy Information Point PIP]
    D --> E[Attribute Sources]
    C --> F[Policy Administration Point PAP]
    F --> G[Policy Store]
    C --> B
    B --> H{Decision}
    H -->|Permit| I[Allow Access]
    H -->|Deny| J[Deny Access]
```

### Authorization Best Practices

1. **Principle of Least Privilege**: Grant minimum necessary permissions
2. **Separation of Duties**: Prevent conflicts of interest
3. **Time-Bound Access**: Implement expiring permissions
4. **Regular Reviews**: Periodic access certification
5. **Centralized Policy Management**: Single source of truth for policies

---

## Federation Architecture

### What is Federation?

Federation enables identity information to be shared across organizational boundaries, allowing users to access resources in partner organizations using their home credentials.

### Federation Trust Models

```mermaid
graph TD
    subgraph "Direct Federation"
        A1[Organization A] <-->|Trust| B1[Organization B]
    end
    
    subgraph "Hub-and-Spoke Federation"
        H[Identity Hub]
        C1[Org A] --> H
        C2[Org B] --> H
        C3[Org C] --> H
        C4[Org D] --> H
    end
    
    subgraph "Mesh Federation"
        D1[Org A] <--> D2[Org B]
        D2 <--> D3[Org C]
        D3 <--> D1
    end
```

### Federation Protocols Comparison

| Aspect | SAML 2.0 | OpenID Connect | WS-Federation |
|--------|----------|----------------|---------------|
| **Token Format** | XML | JWT | XML |
| **Transport** | HTTP POST/Redirect | HTTP | HTTP |
| **Primary Use** | Enterprise SSO | Web/Mobile apps | Microsoft ecosystem |
| **Complexity** | High | Low | Medium |
| **Mobile Support** | Limited | Excellent | Limited |

### Cross-Domain Identity Flow

```mermaid
sequenceDiagram
    participant User
    participant SP as Service Provider (Org B)
    participant IdP_B as IdP (Org B)
    participant IdP_A as IdP (Org A - Home)
    
    User->>SP: 1. Access Resource
    SP->>IdP_B: 2. Authentication Request
    IdP_B->>IdP_B: 3. Detect Home Realm
    IdP_B->>IdP_A: 4. Federated Auth Request
    User->>IdP_A: 5. Authenticate at Home IdP
    IdP_A-->>IdP_B: 6. Return Assertion
    IdP_B->>IdP_B: 7. Transform Claims
    IdP_B-->>SP: 8. Return Token
    SP-->>User: 9. Grant Access
```

---

## Managed Identity Architecture

### What is Managed Identity?

Managed Identity is a cloud-native pattern that provides an automatically managed identity for applications and services to authenticate to cloud resources without storing credentials in code. The cloud platform handles credential creation, rotation, and lifecycle management.

### The Problem Managed Identity Solves

```
┌─────────────────────────────────────────────────────────────────┐
│               TRADITIONAL vs MANAGED IDENTITY                   │
├─────────────────────────────────────────────────────────────────┤
│  Traditional Approach (Problematic):                            │
│  ┌─────────────┐     Secrets in:                               │
│  │ Application │ --> • Config files                            │
│  │             │     • Environment variables                   │
│  │             │     • Key vaults (still need auth!)           │
│  └─────────────┘     • Source code (worst case)                │
│                                                                 │
│  ⚠️ Risks: Credential exposure, rotation burden, sprawl        │
├─────────────────────────────────────────────────────────────────┤
│  Managed Identity Approach (Secure):                            │
│  ┌─────────────┐     Platform provides:                        │
│  │ Application │ --> • Automatic credential injection          │
│  │             │     • Automatic rotation                      │
│  │             │     • No secrets to manage                    │
│  └─────────────┘     • Identity tied to resource lifecycle     │
│                                                                 │
│  ✅ Benefits: Zero credential management, reduced attack surface│
└─────────────────────────────────────────────────────────────────┘
```

### Types of Managed Identities

| Type | Description | Lifecycle | Use Case |
|------|-------------|-----------|----------|
| **System-Assigned** | Created with and tied to a specific resource | Deleted when resource is deleted | Single resource needs specific access |
| **User-Assigned** | Standalone identity resource | Independent of resources | Shared identity across multiple resources |

### Managed Identity Architecture Pattern

```mermaid
flowchart TD
    subgraph "Application Layer"
        A[Application/Service]
    end
    
    subgraph "Identity Platform"
        B[Managed Identity]
        C[Token Service/IMDS]
        D[Identity Provider]
    end
    
    subgraph "Target Resources"
        E[Database]
        F[Storage]
        G[Key Vault]
        H[Other Services]
    end
    
    A -->|1. Request Token| C
    C -->|2. Validate Identity| B
    B -->|3. Authenticate| D
    D -->|4. Issue Token| C
    C -->|5. Return Token| A
    A -->|6. Access with Token| E & F & G & H
```

### System-Assigned vs User-Assigned Comparison

```mermaid
graph TB
    subgraph "System-Assigned Identity"
        SA1[VM 1] --> SAI1[Identity 1]
        SA2[VM 2] --> SAI2[Identity 2]
        SA3[App Service] --> SAI3[Identity 3]
        
        SAI1 --> R1[Resource A]
        SAI2 --> R1
        SAI3 --> R1
    end
    
    subgraph "User-Assigned Identity"
        UA1[VM 1] --> UAI[Shared Identity]
        UA2[VM 2] --> UAI
        UA3[App Service] --> UAI
        
        UAI --> R2[Resource A]
        UAI --> R3[Resource B]
    end
```

### When to Use Each Type

```
┌─────────────────────────────────────────────────────────────────┐
│           MANAGED IDENTITY TYPE SELECTION GUIDE                 │
├─────────────────────────────────────────────────────────────────┤
│  Scenario                        │  Recommended Type            │
├──────────────────────────────────┼──────────────────────────────┤
│  Single resource, unique access  │  System-Assigned             │
│  needs                           │                              │
├──────────────────────────────────┼──────────────────────────────┤
│  Multiple resources need same    │  User-Assigned               │
│  permissions                     │                              │
├──────────────────────────────────┼──────────────────────────────┤
│  Identity must outlive resource  │  User-Assigned               │
├──────────────────────────────────┼──────────────────────────────┤
│  Need pre-provisioned identity   │  User-Assigned               │
│  before resource creation        │                              │
├──────────────────────────────────┼──────────────────────────────┤
│  Simple, auto-cleanup preferred  │  System-Assigned             │
├──────────────────────────────────┼──────────────────────────────┤
│  VMSS or container instances     │  User-Assigned (recommended) │
│  with shared access              │                              │
└─────────────────────────────────────────────────────────────────┘
```

### Token Acquisition Flow

```mermaid
sequenceDiagram
    participant App as Application
    participant IMDS as Instance Metadata Service
    participant AAD as Identity Provider
    participant Res as Target Resource
    
    App->>IMDS: 1. GET /token?resource=https://storage.example.com
    Note over IMDS: Endpoint only accessible from within the resource
    IMDS->>AAD: 2. Request token for managed identity
    AAD->>AAD: 3. Validate identity exists and is enabled
    AAD-->>IMDS: 4. Return access token
    IMDS-->>App: 5. Return token (JWT)
    App->>Res: 6. API call with Bearer token
    Res->>Res: 7. Validate token signature & claims
    Res-->>App: 8. Return requested data
```

### Managed Identity Implementation Patterns

#### Pattern 1: Direct Resource Access

```
Application ──(Managed Identity)──> Azure SQL Database
                                    └── No connection string secrets!
```

#### Pattern 2: Secure Secret Retrieval

```
Application ──(Managed Identity)──> Key Vault ──> Retrieve third-party secrets
                                                  └── For non-Azure resources
```

#### Pattern 3: Service Chaining

```
Function App ──(MI)──> Service Bus ──(trigger)──> Another Function ──(MI)──> Cosmos DB
```

### Security Boundaries

```
┌─────────────────────────────────────────────────────────────────┐
│              MANAGED IDENTITY SECURITY MODEL                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Token Endpoint (IMDS)                                          │
│  ├── Only accessible from within the resource                   │
│  ├── Not routable from outside (169.254.169.254)               │
│  ├── No authentication required (relies on network isolation)   │
│  └── Short-lived tokens (typically 1 hour)                      │
│                                                                 │
│  Identity Scope                                                 │
│  ├── Bound to specific cloud resource                          │
│  ├── Cannot be extracted or used elsewhere                      │
│  └── Permissions granted via RBAC on target resources           │
│                                                                 │
│  Credential Management                                          │
│  ├── Platform manages all certificates/keys                     │
│  ├── Automatic rotation (no manual intervention)                │
│  └── No credentials exposed to application code                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Managed Identity Best Practices

| Practice | Description |
|----------|-------------|
| **Use least privilege** | Grant only necessary permissions to the identity |
| **Prefer system-assigned for simplicity** | Unless you need identity sharing or pre-provisioning |
| **Use user-assigned for scale sets** | Avoids identity proliferation in dynamic environments |
| **Enable on all supported resources** | Eliminate service account passwords wherever possible |
| **Monitor identity usage** | Track token acquisitions and resource access |
| **Combine with Conditional Access** | Apply policies based on workload identity |
| **Use for Key Vault access** | Bootstrap other secrets securely |

### Cloud Provider Implementations

| Provider | Feature Name | Metadata Service |
|----------|--------------|------------------|
| **Azure** | Managed Identity (System/User-Assigned) | IMDS (169.254.169.254) |
| **AWS** | IAM Roles for EC2/ECS/Lambda | IMDS (169.254.169.254) |
| **GCP** | Service Account (attached) | Metadata Server (169.254.169.254) |
| **Kubernetes** | Workload Identity / Service Account Token | Projected Service Account Tokens |

### Common Use Cases

1. **Database Access**: Connect to managed databases without connection string secrets
2. **Storage Operations**: Read/write blobs, queues without storage keys
3. **Secret Management**: Access Key Vault/Secret Manager to retrieve third-party credentials
4. **Service Communication**: Authenticate between microservices
5. **CI/CD Pipelines**: Deploy resources without storing deployment credentials
6. **Logging & Monitoring**: Send telemetry to monitoring services securely

---

## Identity Lifecycle Management

### Identity Lifecycle Stages

```mermaid
stateDiagram-v2
    [*] --> Provisioning: User Onboarding
    Provisioning --> Active: Account Created
    Active --> Modified: Role Change
    Modified --> Active: Update Complete
    Active --> Suspended: Leave of Absence
    Suspended --> Active: Return
    Active --> Deprovisioning: Offboarding
    Suspended --> Deprovisioning: Termination
    Deprovisioning --> Archived: Retention Period
    Archived --> [*]: Data Deleted
```

### Provisioning Patterns

#### 1. Just-In-Time (JIT) Provisioning

```mermaid
sequenceDiagram
    participant User
    participant App
    participant IdP
    participant UserStore as User Store
    
    User->>App: First Access
    App->>IdP: Auth Request
    User->>IdP: Authenticate
    IdP-->>App: Token with Claims
    App->>UserStore: Check User Exists?
    UserStore-->>App: User Not Found
    App->>UserStore: Create User from Claims
    UserStore-->>App: User Created
    App-->>User: Access Granted
```

#### 2. SCIM-Based Provisioning

```mermaid
flowchart LR
    subgraph "Source System"
        A[HR System]
        B[Identity Governance]
    end
    
    subgraph "SCIM Protocol"
        C[Create User]
        D[Update User]
        E[Delete User]
        F[Sync Groups]
    end
    
    subgraph "Target Applications"
        G[SaaS App 1]
        H[SaaS App 2]
        I[SaaS App 3]
    end
    
    A --> B
    B --> C & D & E & F
    C --> G & H & I
    D --> G & H & I
    E --> G & H & I
    F --> G & H & I
```

### Deprovisioning Checklist

| Step | Action | Timeline |
|------|--------|----------|
| 1 | Disable authentication | Immediate |
| 2 | Revoke active sessions | Immediate |
| 3 | Remove group memberships | Within 1 hour |
| 4 | Revoke application access | Within 1 hour |
| 5 | Transfer data ownership | Within 24 hours |
| 6 | Archive user data | Per retention policy |
| 7 | Delete identity record | After retention period |

---

## Identity Governance

### Identity Governance Framework

```mermaid
graph TB
    subgraph "Identity Governance"
        A[Access Reviews]
        B[Entitlement Management]
        C[Privileged Identity Management]
        D[Identity Analytics]
        E[Compliance Reporting]
    end
    
    subgraph "Processes"
        F[Request & Approve]
        G[Certify & Review]
        H[Monitor & Detect]
        I[Report & Audit]
    end
    
    A --> G
    B --> F
    C --> H
    D --> H
    E --> I
```

### Access Reviews

```
┌─────────────────────────────────────────────────────────────────┐
│                     ACCESS REVIEW TYPES                         │
├─────────────────────────────────────────────────────────────────┤
│  Review Type        │  Frequency    │  Reviewer                 │
├─────────────────────┼───────────────┼───────────────────────────┤
│  Self-Review        │  Quarterly    │  User                     │
├─────────────────────┼───────────────┼───────────────────────────┤
│  Manager Review     │  Quarterly    │  Direct Manager           │
├─────────────────────┼───────────────┼───────────────────────────┤
│  Resource Owner     │  Monthly      │  Application Owner        │
│  Review             │               │                           │
├─────────────────────┼───────────────┼───────────────────────────┤
│  Privileged Access  │  Monthly      │  Security Team            │
│  Review             │               │                           │
├─────────────────────┼───────────────┼───────────────────────────┤
│  External User      │  Quarterly    │  Sponsor                  │
│  Review             │               │                           │
└─────────────────────────────────────────────────────────────────┘
```

### Privileged Identity Management (PIM)

```mermaid
flowchart TD
    A[User Requests Privileged Role] --> B{Approval Required?}
    B -->|Yes| C[Manager/Admin Approves]
    B -->|No| D[Self-Approval with MFA]
    C --> E{Approved?}
    D --> F[Role Activated]
    E -->|Yes| F
    E -->|No| G[Request Denied]
    F --> H[Time-Bound Activation]
    H --> I[Perform Privileged Task]
    I --> J[Role Automatically Expires]
    J --> K[Audit Log Created]
```

---

## Best Practices

### Identity Architecture Best Practices

1. **Centralize Identity Management**
   - Use a single source of truth for identities
   - Implement consistent policies across applications

2. **Implement Strong Authentication**
   - Require MFA for all users
   - Adopt passwordless where possible
   - Use risk-based authentication

3. **Apply Least Privilege**
   - Grant minimum necessary access
   - Use time-bound and just-in-time access
   - Regular access reviews

4. **Secure Service Identities**
   - Use managed identities for workloads
   - Rotate credentials automatically
   - Avoid storing secrets in code

5. **Plan for Federation**
   - Design for cross-organization scenarios
   - Standardize on modern protocols (OIDC)
   - Implement proper claim mapping

6. **Automate Lifecycle Management**
   - HR-driven provisioning/deprovisioning
   - Automated access reviews
   - Self-service with approval workflows

7. **Monitor and Audit**
   - Log all authentication events
   - Detect anomalous behavior
   - Maintain compliance evidence

### Common Anti-Patterns to Avoid

| Anti-Pattern | Risk | Better Approach |
|--------------|------|-----------------|
| Shared accounts | No accountability | Individual accounts with RBAC |
| Static service credentials | Credential exposure | Managed identities, certificate rotation |
| Over-provisioning | Excessive access | Least privilege, JIT access |
| No session management | Session hijacking | Token lifetime limits, continuous validation |
| Local identity stores | Inconsistent security | Centralized IdP |

---

## Related Resources

### Internal Documentation

- [6.1 Security Architecture](6.1-security-architecture.md)
- [Authentication Methods Overview](authentication-methods-overview.md)
- [Azure Identity Overview](../../architecture-azure/security/azure_identity_overview.md)
- [Azure Identity Principal Objects](../../architecture-azure/security/azure-identity-principal-objects.md)

### External References

- [NIST Digital Identity Guidelines (SP 800-63)](https://pages.nist.gov/800-63-3/)
- [OAuth 2.0 RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)
- [OpenID Connect Specification](https://openid.net/connect/)
- [SAML 2.0 Specification](http://docs.oasis-open.org/security/saml/v2.0/)
- [SCIM Protocol](https://datatracker.ietf.org/doc/html/rfc7644)

---

*Last Updated: December 2024*
